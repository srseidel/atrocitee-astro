/**
 * Debug Utility
 * 
 * Provides environment-aware logging that respects ENABLE_TEST_MODE.
 * In development/test mode: logs to console
 * In production: suppresses debug logs (Sentry temporarily disabled for build fix)
 */

// Temporarily disable Sentry import to fix escape build error
// import * as Sentry from '@sentry/astro';

/**
 * Check if debug mode is enabled
 */
const isDebugEnabled = (): boolean => {
  // If ENABLE_TEST_MODE is explicitly set, respect that setting
  if (import.meta.env.ENABLE_TEST_MODE !== undefined) {
    return import.meta.env.ENABLE_TEST_MODE === 'true';
  }
  // Otherwise, default to DEV mode
  return import.meta.env.DEV === true;
};

/**
 * Check if we're in production mode
 */
const isProduction = (): boolean => {
  // If ENABLE_TEST_MODE is explicitly set to false, we're in production mode
  if (import.meta.env.ENABLE_TEST_MODE === 'false') {
    return true;
  }
  // Otherwise, use the default Astro PROD setting
  return import.meta.env.PROD === true && 
         import.meta.env.ENABLE_TEST_MODE !== 'true';
};

/**
 * Sanitize sensitive data from any input for safe logging
 */
const sanitizeData = (data: any): any => {
  if (typeof data === 'string') {
    // Remove potential sensitive patterns
    return data
      .replace(/password[^&\s]*[=:][^&\s]*/gi, 'password=***')
      .replace(/token[^&\s]*[=:][^&\s]*/gi, 'token=***')
      .replace(/key[^&\s]*[=:][^&\s]*/gi, 'key=***')
      .replace(/secret[^&\s]*[=:][^&\s]*/gi, 'secret=***');
  }
  
  if (Array.isArray(data)) {
    return data.map(item => sanitizeData(item));
  }
  
  if (typeof data === 'object' && data !== null) {
    const sanitized: any = {};
    Object.keys(data).forEach(key => {
      const lowerKey = key.toLowerCase();
      if (lowerKey.includes('password') ||
          lowerKey.includes('token') ||
          lowerKey.includes('key') ||
          lowerKey.includes('secret') ||
          lowerKey.includes('auth') ||
          lowerKey.includes('credential')) {
        sanitized[key] = '***';
      } else {
        sanitized[key] = sanitizeData(data[key]);
      }
    });
    return sanitized;
  }
  
  return data;
};

/**
 * Sanitize sensitive data specifically for production logging
 */
const sanitizeForProduction = (data: any): any => {
  return sanitizeData(data);
};

/**
 * Debug utility with environment-aware logging
 */
export const debug = {
  /**
   * Debug level logging - only in debug mode
   */
  log: (...args: any[]) => {
    if (isDebugEnabled()) {
      const sanitizedArgs = args.map(arg => sanitizeData(arg));
      console.log('[DEBUG]', ...sanitizedArgs);
    }
  },

  /**
   * Info level logging - only in debug mode  
   */
  info: (...args: any[]) => {
    if (isDebugEnabled()) {
      const sanitizedArgs = args.map(arg => sanitizeData(arg));
      console.info('[INFO]', ...sanitizedArgs);
    }
  },

  /**
   * Warning level logging - only in debug mode
   */
  warn: (...args: any[]) => {
    if (isDebugEnabled()) {
      const sanitizedArgs = args.map(arg => sanitizeData(arg));
      console.warn('[WARN]', ...sanitizedArgs);
    }
  },

  /**
   * Error level logging - only in debug mode
   * For production errors, use criticalError instead
   */
  error: (...args: any[]) => {
    if (isDebugEnabled()) {
      const sanitizedArgs = args.map(arg => sanitizeData(arg));
      console.error('[ERROR]', ...sanitizedArgs);
    }
  },

  /**
   * Critical errors that should always be tracked
   * In debug mode: logs to console with full details
   * In production: sends to Sentry with sanitized data
   */
  criticalError: (message: string, error?: any, context?: Record<string, any>) => {
    // Always sanitize context data before any logging
    const sanitizedContext = context ? sanitizeData(context) : context;
    
    if (isDebugEnabled()) {
      // Development: Console logging with sanitized context only
      console.error('[CRITICAL]', message, error, sanitizedContext);
    } else if (isProduction()) {
      // Production: Send to Sentry with sanitized data
      try {
        const sanitizedError = error ? sanitizeForProduction(error) : undefined;
        
        // TODO: Re-enable Sentry after fixing escape variable conflict
        // Sentry.withScope((scope) => {
        //   if (sanitizedContext) {
        //     Object.keys(sanitizedContext).forEach(key => {
        //       scope.setTag(key, sanitizedContext[key]);
        //     });
        //   }
        //   
        //   if (sanitizedError instanceof Error) {
        //     Sentry.captureException(sanitizedError);
        //   } else {
        //     Sentry.captureMessage(message, 'error');
        //   }
        // });
        
        // Also log a clean message to console for server logs
        console.error('[ERROR]', message);
      } catch (sentryError) {
        // Fallback if Sentry fails
        console.error('[ERROR]', message);
        console.error('[SENTRY_ERROR]', sentryError);
      }
    }
  },

  /**
   * User-facing errors that should be captured but not expose sensitive data
   */
  userError: (userMessage: string, technicalError?: any, context?: Record<string, any>) => {
    if (isDebugEnabled()) {
      const sanitizedContext = context ? sanitizeData(context) : context;
      console.error('[USER_ERROR]', userMessage, technicalError, sanitizedContext);
    } else if (isProduction()) {
      // Send technical details to Sentry but show clean message to user
      debug.criticalError(`User Error: ${userMessage}`, technicalError, context);
      console.error('[USER_ERROR]', userMessage); // Clean message only
    }
  },

  /**
   * Performance logging for optimization
   */
  performance: (label: string, timeMs?: number, data?: any) => {
    if (isDebugEnabled()) {
      const sanitizedData = data ? sanitizeData(data) : data;
      if (timeMs !== undefined) {
        console.log(`[PERF] ${label}: ${timeMs}ms`, sanitizedData);
      } else {
        console.log(`[PERF] ${label}`, sanitizedData);
      }
    }
  },

  /**
   * API request/response logging
   */
  api: (method: string, url: string, status?: number, data?: any) => {
    if (isDebugEnabled()) {
      const sanitizedData = data ? sanitizeData(data) : data;
      console.log(`[API] ${method} ${url}`, status ? `(${status})` : '', sanitizedData);
    }
  },

  /**
   * Database operation logging
   */
  db: (operation: string, table?: string, data?: any) => {
    if (isDebugEnabled()) {
      const sanitizedData = data ? sanitizeData(data) : data;
      console.log(`[DB] ${operation}`, table, sanitizedData);
    }
  },

  /**
   * Authentication/authorization logging
   */
  auth: (action: string, user?: string, data?: any) => {
    if (isDebugEnabled()) {
      const sanitizedData = data ? sanitizeData(data) : data;
      console.log(`[AUTH] ${action}`, user, sanitizedData);
    }
  }
};

/**
 * Performance timing utility
 */
export const perfTimer = (label: string) => {
  const start = performance.now();
  
  return {
    end: (data?: any) => {
      const duration = performance.now() - start;
      debug.performance(label, duration, data);
      return duration;
    }
  };
};

/**
 * Debug mode status
 */
export const debugStatus = {
  isEnabled: isDebugEnabled(),
  isProduction: isProduction(),
  mode: isDebugEnabled() ? 'debug' : 'production'
};