---
// @ts-nocheck - Disable TypeScript checking for Astro-specific attributes like 'class' vs 'className'

import Layout from '@layouts/MainLayout.astro';
import ProductCard from '@components/features/products/ProductCard.astro';
import { createClient } from '@lib/supabase/client';
import type { Database } from '@local-types/database/schema';
import type { GetStaticPaths } from 'astro';

// Add prerender option
export const prerender = true;

type Product = Database['public']['Tables']['products']['Row'];
type ProductVariant = Database['public']['Tables']['product_variants']['Row'];
type Tag = Database['public']['Tables']['tags']['Row'];
type Category = Database['public']['Tables']['categories']['Row'];

interface ProductWithRelations extends Product {
  product_variants: ProductVariant[];
  categories: Category;
  product_tags: {
    tag_id: string;
    tags: Tag;
  }[];
}

// Get all tag slugs at build time
export const getStaticPaths = (async () => {
  const supabase = createClient();
  
  // Get all active tags
  const { data: tags = [] } = await supabase
    .from('tags')
    .select('*')
    .eq('active', true);

  // Get all published products with their tags and categories
  const { data: products = [] } = await supabase
    .from('products')
    .select(`
      *,
      product_variants (
        id,
        retail_price,
        in_stock,
        stock_level,
        mockup_settings,
        options,
        printful_id,
        printful_external_id
      ),
      categories!inner (
        *
      ),
      product_tags!inner (
        tag_id,
        tags!inner (
          id,
          name,
          slug
        )
      )
    `)
    .eq('published_status', true);

  // Process products to include variant data and images
  const processProducts = (productList: any[]) => {
    return productList.map(product => {
      // Find the first variant with mockup settings
      const variantWithMockup = product.product_variants?.find((v: any) => 
        v.mockup_settings?.views && v.mockup_settings.views.length > 0
      );
      
      // Get the front view mockup if available
      const frontMockup = variantWithMockup?.mockup_settings?.views?.find((v: any) => v.view === 'front');
      
      // If no front view, get the first available mockup
      const firstMockup = variantWithMockup?.mockup_settings?.views?.[0];
      
      // Use mockup image URL if available, otherwise fallback to thumbnail_url
      const imageUrl = frontMockup?.url || firstMockup?.url || product.thumbnail_url;
      
      // Process variants for cart functionality
      const variants = product.product_variants?.map((variant: any) => {
        // Convert Printful options array to object format
        const optionsObj: Record<string, string> = {};
        if (variant.options && Array.isArray(variant.options)) {
          variant.options.forEach((opt: any) => {
            if (opt.id && opt.value) {
              optionsObj[opt.id] = opt.value;
            }
          });
        }
        
        return {
          id: variant.id,
          name: `${optionsObj.color || 'Default'} - ${optionsObj.size || 'One Size'}`,
          options: optionsObj,
          price: variant.retail_price || product.atrocitee_base_price || 0,
          imageUrl: imageUrl,
          printful_id: variant.printful_id,
          printful_external_id: variant.printful_external_id
        };
      }) || [];
      
      // Use the first variant's price, or base price as fallback
      const displayPrice = variants[0]?.price || product.atrocitee_base_price || 0;
      
      return {
        ...product,
        imageUrl,
        variants,
        displayPrice,
      };
    });
  };

  // Group products by tag
  const productsByTag = new Map<string, any[]>();
  
  // Check if products is null or undefined before using forEach
  if (products && Array.isArray(products)) {
    products.forEach(product => {
      if (product.product_tags && Array.isArray(product.product_tags)) {
        product.product_tags.forEach(pt => {
          const tag = pt.tags;
          if (tag?.slug) {
            if (!productsByTag.has(tag.slug)) {
              productsByTag.set(tag.slug, []);
            }
            productsByTag.get(tag.slug)?.push(product);
          }
        });
      }
    });
    
    // Process products for each tag
    productsByTag.forEach((products, tagSlug) => {
      productsByTag.set(tagSlug, processProducts(products));
    });
  }

  // Return array of tag pages to generate
  // Make sure tags is an array before mapping
  if (!tags || !Array.isArray(tags)) {
    return [];
  }
  
  return tags.map((tag) => ({
    params: { tag: tag.slug },
    props: { 
      tag,
      products: productsByTag.get(tag.slug) || []
    }
  }));
}) satisfies GetStaticPaths;

const { tag, products = [] } = Astro.props;
---

<Layout title={`${tag.name} Products - Shop`}>
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
    {/* Tag header */}
    <div class="text-center mb-12">
      <h1 class="text-4xl font-extrabold tracking-tight text-gray-900 sm:text-5xl">
        {tag.name}
      </h1>
      {tag.description && (
        <p class="mt-4 text-xl text-gray-500">
          {tag.description}
        </p>
      )}
    </div>

    {/* Products grid */}
    <div class="grid grid-cols-1 gap-y-10 gap-x-6 sm:grid-cols-2 lg:grid-cols-4 xl:gap-x-8">
      {products.map((product: ProductWithRelations) => (
        <ProductCard
          productId={product.id}
          productSlug={product.slug}
          name={product.name}
          price={product.displayPrice}
          imageUrl={product.imageUrl || 'https://via.placeholder.com/300'}
          description={product.description || ''}
          category={tag.name}
          variants={product.variants}
          badge={product.atrocitee_featured ? "featured" : undefined}
        />
      ))}
    </div>

    {/* Show message if no products */}
    {products.length === 0 && (
      <div class="text-center py-12">
        <h3 class="text-lg font-medium text-gray-900">No products found</h3>
        <p class="mt-2 text-sm text-gray-500">
          Check back soon for new products with this tag.
        </p>
      </div>
    )}
  </div>
</Layout> 