---
// @ts-nocheck - Disable TypeScript checking for Astro-specific attributes like 'class' vs 'className'
import Layout from '@layouts/MainLayout.astro';
import ProductCard from '@components/features/products/ProductCard.astro';
import { createClient } from '@lib/supabase/client';
import type { Database } from '@local-types/database/schema';
import type { GetStaticPaths } from 'astro';

// Add prerender option
export const prerender = true;

type Product = Database['public']['Tables']['products']['Row'];
type ProductVariant = Database['public']['Tables']['product_variants']['Row'];
type Category = Database['public']['Tables']['atrocitee_categories']['Row'];

interface ProductWithCategory extends Product {
  product_variants: ProductVariant[];
  atrocitee_categories: Category;
}

// Get all categories and their products at build time
export const getStaticPaths = (async () => {
  const supabase = createClient();

  // Get all active categories
  const { data: categories = [] } = await supabase
    .from('atrocitee_categories')
    .select('*')
    .eq('is_active', true);

  // Get all published products with their categories
  const { data: products = [] } = await supabase
    .from('products')
    .select(`
      *,
      product_variants (
        id,
        retail_price,
        in_stock,
        stock_level,
        mockup_settings,
        options,
        printful_id,
        printful_external_id
      ),
      atrocitee_categories!inner (
        *
      )
    `)
    .eq('published_status', true);

  // Process products to include variant data and images
  const processProducts = (productList) => {
    return productList.map(product => {
      // Find the first variant with mockup settings
      const variantWithMockup = product.product_variants?.find((v) => 
        v.mockup_settings?.views && v.mockup_settings.views.length > 0
      );
      
      // Get the front view mockup if available
      const frontMockup = variantWithMockup?.mockup_settings?.views?.find((v) => v.view === 'front');
      
      // If no front view, get the first available mockup
      const firstMockup = variantWithMockup?.mockup_settings?.views?.[0];
      
      // Use mockup image URL if available, otherwise fallback to thumbnail_url
      const imageUrl = frontMockup?.url || firstMockup?.url || product.thumbnail_url;
      
      // Process variants for cart functionality
      const variants = product.product_variants?.map((variant) => {
        // Convert Printful options array to object format
        const optionsObj: Record<string, string> = {};
        if (variant.options && Array.isArray(variant.options)) {
          variant.options.forEach((opt: any) => {
            if (opt.id && opt.value) {
              optionsObj[opt.id] = opt.value;
            }
          });
        }
        
        return {
          id: variant.id,
          name: `${optionsObj.color || 'Default'} - ${optionsObj.size || 'One Size'}`,
          options: optionsObj,
          price: variant.retail_price || product.atrocitee_base_price || 0,
          imageUrl: imageUrl,
          printful_id: variant.printful_id,
          printful_external_id: variant.printful_external_id
        };
      }) || [];
      
      // Use the first variant's price, or base price as fallback
      const displayPrice = variants[0]?.price || product.atrocitee_base_price || 0;
      
      return {
        ...product,
        imageUrl,
        variants,
        displayPrice,
      };
    });
  };

  // Group products by category
  const productsByCategory = {};
  if (products && Array.isArray(products)) {
    products.forEach(product => {
      const categoryId = product.atrocitee_categories?.id;
      if (categoryId) {
        if (!productsByCategory[categoryId]) {
          productsByCategory[categoryId] = [];
        }
        productsByCategory[categoryId].push(product);
      }
    });
    
    // Process products for each category
    for (const categoryId in productsByCategory) {
      productsByCategory[categoryId] = processProducts(productsByCategory[categoryId]);
    }
  }

  // Return array of category pages to generate
  if (!categories || !Array.isArray(categories)) {
    return [];
  }
  
  return categories.map((category) => ({
    params: { category: category.slug },
    props: { 
      category,
      products: productsByCategory[category.id] || []
    }
  }));
}) satisfies GetStaticPaths;

const { category, products = [] } = Astro.props;
---

<Layout title={`${category.name} - Shop`}>
  {/* Category hero */}
  <div class="relative">
    <div class="absolute inset-0">
      <img
        class="w-full h-64 object-cover"
        src="https://via.placeholder.com/1920x384"
        alt={category.name}
      />
      <div class="absolute inset-0 bg-gray-900 bg-opacity-50"></div>
    </div>
    <div class="relative max-w-7xl mx-auto py-24 px-4 sm:py-32 sm:px-6 lg:px-8">
      <h1 class="text-4xl font-extrabold tracking-tight text-white sm:text-5xl lg:text-6xl">
        {category.name}
      </h1>
      {category.description && (
        <p class="mt-6 text-xl text-white max-w-3xl">
          {category.description}
        </p>
      )}
    </div>
  </div>

  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
    {/* Products grid */}
    <div class="grid grid-cols-1 gap-y-10 gap-x-6 sm:grid-cols-2 lg:grid-cols-4 xl:gap-x-8">
      {products.map((product) => (
        <ProductCard
          productId={product.id}
          productSlug={product.slug}
          name={product.name}
          price={product.displayPrice}
          imageUrl={product.imageUrl || 'https://via.placeholder.com/300'}
          description={product.description || ''}
          category={category.name}
          variants={product.variants}
          badge={product.atrocitee_featured ? "featured" : undefined}
        />
      ))}
    </div>

    {/* Show message if no products */}
    {products.length === 0 && (
      <div class="text-center py-12">
        <h3 class="text-lg font-medium text-gray-900">No products found</h3>
        <p class="mt-2 text-sm text-gray-500">
          Check back soon for new products in this category.
        </p>
      </div>
    )}
  </div>
</Layout> 