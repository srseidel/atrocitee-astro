---
import { createClient } from '@lib/supabase/client';
import Layout from '@layouts/Layout.astro';
import type { Database } from '@local-types/database/schema';
import { generateMockupFilename } from '@lib/mockups/utils';
import { parseMockupFilename, getViewLabel } from '@utils/helpers/mockups';

// Enable static generation for this page
export const prerender = true;

// Get all product slugs at build time
export async function getStaticPaths() {
  const supabase = createClient();
  
  // Fetch all published products
  const { data: products, error } = await supabase
    .from('products')
    .select('slug')
    .eq('published_status', true);
    
  if (error) {
    console.error('Error fetching products for static paths:', error);
    return [];
  }
  
  // Return array of objects with params for each product
  return products.map(product => ({
    params: { slug: product.slug }
  }));
}

interface MockupView {
  view: string;
  label: string;
  filename: string;
  url: string;
  webpUrl: string;
}

interface ProductVariant {
  id: string;
  name: string;
  sku: string;
  retail_price: number | null;
  options: {
    color?: string;
    size?: string;
    [key: string]: any;
  };
  in_stock: boolean;
  stock_level: number | null;
  mockup_settings?: {
    views: Array<{
      view: string;
      filename: string;
      url: string;
      webpUrl: string;
    }>;
  };
}

interface PublicCharity {
  id: string;
  name: string;
  description: string | null;
  website_url: string | null;
  logo_url: string | null;
  active: boolean;
}

type Product = Database['public']['Tables']['products']['Row'] & {
  product_variants: ProductVariant[];
  public_charities?: PublicCharity | null;
  atrocitee_category_id: number;
  atrocitee_featured?: boolean;
  atrocitee_base_price?: number;
  atrocitee_donation_amount?: number;
};

// Get the slug from the URL
const { slug } = Astro.params;

if (!slug) {
  return Astro.redirect('/404');
}

// Initialize Supabase client
const supabase = createClient();

// Fetch the product by slug
const { data: product, error: productError } = await supabase
  .from('products')
  .select(`
    *,
    product_variants (
      id,
      retail_price,
      options,
      in_stock,
      stock_level,
      name,
      sku,
      mockup_settings
    ),
    public_charities (
      name,
      description,
      website_url,
      logo_url,
      active
    ),
    atrocitee_categories (
      id,
      name,
      slug,
      is_active
    )
  `)
  .eq('slug', slug)
  .eq('published_status', true)
  .single();

// Handle product not found
if (productError || !product) {
  return Astro.redirect('/404');
}

// Process variants for the client-side
const processedVariants = product.product_variants.map((variant: ProductVariant) => {
  // Get mockup views from mockup_settings
  const mockupViews = variant.mockup_settings?.views?.map(view => {
    // Generate the standardized filename
    const filename = generateMockupFilename(
      product.slug,
      variant.options.color || 'unknown',
      variant.options.size || '',
      view.view
    ).replace('.png', ''); // Remove extension as we'll add it for each format

    // Get the human-readable view label
    const viewLabel = getViewLabel(view.view);

    return {
      view: view.view,
      label: viewLabel,
      filename,
      url: `/images/mockups/${product.slug}/${filename}.png`,
      webpUrl: `/images/mockups/${product.slug}/${filename}.webp`
    };
  }) || [];

  return {
    id: variant.id,
    retail_price: variant.retail_price,
    options: variant.options,
    name: variant.name,
    sku: variant.sku,
    mockupViews
  };
});

// Extract available colors and sizes
const availableColors = [...new Set(processedVariants.map((v: ProductVariant) => v.options.color))].filter(Boolean) as string[];
const availableSizes = [...new Set(processedVariants.map((v: ProductVariant) => v.options.size))].filter((size): size is string => Boolean(size)).sort((a: string, b: string) => {
  const sizeOrder: Record<string, number> = { 
    "XS": 1, "S": 2, "M": 3, "L": 4, "XL": 5, "2XL": 6, "3XL": 7, "4XL": 8 
  };
  return (sizeOrder[a] || 99) - (sizeOrder[b] || 99);
});

// Get initial variant
const initialVariant = processedVariants[0];
const initialColor = initialVariant?.options.color || availableColors[0] || 'Black';
const initialSize = initialVariant?.options.size || availableSizes[0] || 'M';

// Get all available views for the initial variant
const initialViews = initialVariant?.mockupViews || [];
---

<Layout title={product.name}>
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
    <div class="lg:grid lg:grid-cols-2 lg:gap-x-8 lg:items-start">
      <div class="flex flex-col">
        <div class="aspect-w-1 aspect-h-1 rounded-lg bg-gray-100 overflow-hidden" id="main-image-container">
          {initialViews.length > 0 ? (
            <picture id="main-image">
              <source srcset={initialViews[0].webpUrl} type="image/webp" />
              <img
                src={initialViews[0].url || product.thumbnail_url}
                alt={`${product.name} in ${initialColor}, size ${initialSize}`}
                class="w-full h-full object-center object-cover"
                onerror="this.onerror=null; this.src=this.getAttribute('data-fallback');"
                data-fallback={product.thumbnail_url || ''}
              />
            </picture>
          ) : (
            <img
              src={product.thumbnail_url || ''}
              alt={`${product.name} in ${initialColor}, size ${initialSize}`}
              class="w-full h-full object-center object-cover"
            />
          )}
        </div>
        
        <div class="mt-4 grid grid-cols-6 gap-2" id="view-thumbnails">
          {initialViews.map((view: MockupView, index: number) => (
            <div 
              class={`aspect-w-1 aspect-h-1 rounded-md bg-gray-100 overflow-hidden cursor-pointer border-2 ${index === 0 ? 'border-indigo-600' : 'border-gray-200'}`} 
              data-view={view.view}
              data-url={view.url}
              data-webp-url={view.webpUrl}
            >
              <picture>
                <source srcset={view.webpUrl} type="image/webp" />
                <img
                  src={view.url}
                  alt={`${view.label} view of ${product.name} in ${initialColor}, size ${initialSize}`}
                  class="w-full h-full object-center object-cover"
                  loading={index > 0 ? "lazy" : "eager"}
                  onerror="this.onerror=null; this.closest('[data-view]').style.display='none';"
                />
              </picture>
              <div class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-20 opacity-0 hover:opacity-100 transition-opacity">
                <span class="text-white text-xs font-medium px-2 py-1 rounded bg-black bg-opacity-50">
                  {view.label}
                </span>
              </div>
            </div>
          ))}
        </div>
      </div>

      <div class="mt-10 px-4 sm:px-0 sm:mt-16 lg:mt-0">
        <h1 class="text-3xl font-extrabold tracking-tight text-gray-900">{product.name}</h1>
        
        <div class="mt-3">
          <h2 class="sr-only">Product information</h2>
          <p class="text-3xl text-gray-900" id="product-price">
            ${initialVariant?.retail_price?.toFixed(2) || product.atrocitee_base_price?.toFixed(2)}
          </p>
        </div>

        <div class="mt-6">
          <h3 class="sr-only">Description</h3>
          <div class="text-base text-gray-700 space-y-6">
            <p>{product.description}</p>
          </div>
        </div>

        {availableColors.length > 0 && (
          <div class="mt-8">
            <h3 class="text-sm text-gray-900 font-medium">Color</h3>
            <div class="grid grid-cols-4 gap-4 mt-4">
              {availableColors.map((color: string) => (
                <button
                  type="button"
                  class={`group relative border rounded-md py-3 px-4 flex items-center justify-center text-sm font-medium focus:outline-none sm:flex-1 ${
                    color === initialColor 
                      ? 'bg-indigo-600 border-transparent text-white option-selected' 
                      : 'bg-white border-gray-300 text-gray-900'
                  }`}
                  data-option="color"
                  data-value={color}
                >
                  {color}
                </button>
              ))}
            </div>
          </div>
        )}

        {availableSizes.length > 0 && (
          <div class="mt-8">
            <h3 class="text-sm text-gray-900 font-medium">Size</h3>
            <div class="grid grid-cols-4 gap-4 mt-4">
              {availableSizes.map((size: string) => (
                <button
                  type="button"
                  class={`group relative border rounded-md py-3 px-4 flex items-center justify-center text-sm font-medium focus:outline-none sm:flex-1 ${
                    size === initialSize 
                      ? 'bg-indigo-600 border-transparent text-white option-selected' 
                      : 'bg-white border-gray-300 text-gray-900'
                  }`}
                  data-option="size"
                  data-value={size}
                >
                  {size}
                </button>
              ))}
            </div>
          </div>
        )}

        <div class="mt-10">
          <button
            type="button"
            class="w-full bg-indigo-600 border border-transparent rounded-md py-3 px-8 flex items-center justify-center text-base font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-50 focus:ring-indigo-500"
          >
            Add to cart
          </button>
        </div>

        {product.public_charities && (
          <div class="mt-10 border-t border-gray-200 pt-10">
            <h3 class="text-sm font-medium text-gray-900">Supporting Charity</h3>
            <div class="mt-4 flex items-center">
              {product.public_charities.logo_url && (
                <img
                  src={product.public_charities.logo_url}
                  alt={product.public_charities.name}
                  class="h-12 w-12 rounded-full"
                />
              )}
              <div class="ml-4">
                <h4 class="text-sm font-medium text-gray-900">{product.public_charities.name}</h4>
                <p class="mt-1 text-sm text-gray-500">{product.public_charities.description}</p>
                {product.public_charities.website_url && (
                  <a
                    href={product.public_charities.website_url}
                    target="_blank"
                    rel="noopener noreferrer"
                    class="mt-2 text-sm text-indigo-600 hover:text-indigo-500"
                  >
                    Learn more about {product.public_charities.name}
                  </a>
                )}
              </div>
            </div>
            <p class="mt-4 text-sm text-gray-500">
              ${product.atrocitee_donation_amount?.toFixed(2)} from each purchase goes to {product.public_charities.name}
            </p>
          </div>
        )}
      </div>
    </div>
  </div>

  <div id="product-data" data-variants={JSON.stringify(processedVariants)} style="display: none;" />
</Layout>

<script define:vars={{ processedVariants, initialColor, initialSize, initialViews }}>
  // Track current selection
  let currentColor = initialColor;
  let currentSize = initialSize;
  let currentVariant = null;
  let currentView = initialViews.length > 0 ? initialViews[0].view : '';

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    initializeProductPage();
  });

  function initializeProductPage() {
    // Set up color selector
    const colorButtons = document.querySelectorAll('[data-color]');
    colorButtons.forEach(button => {
      button.addEventListener('click', (e) => {
        const color = button.getAttribute('data-color');
        if (color) {
          selectColor(color);
        }
      });
    });

    // Set up size selector
    const sizeButtons = document.querySelectorAll('[data-size]');
    sizeButtons.forEach(button => {
      button.addEventListener('click', (e) => {
        const size = button.getAttribute('data-size');
        if (size) {
          selectSize(size);
        }
      });
    });

    // Set up view selector
    const viewButtons = document.querySelectorAll('[data-view]');
    viewButtons.forEach(button => {
      button.addEventListener('click', (e) => {
        const view = button.getAttribute('data-view');
        if (view) {
          selectView(view);
        }
      });
    });

    // Initialize with first variant
    updateUI();
  }

  function selectColor(color) {
    currentColor = color;
    updateUI();
    
    // Update active state on color buttons
    document.querySelectorAll('[data-color]').forEach(btn => {
      if (btn.getAttribute('data-color') === color) {
        btn.classList.add('ring-2', 'ring-primary');
      } else {
        btn.classList.remove('ring-2', 'ring-primary');
      }
    });
  }

  function selectSize(size) {
    currentSize = size;
    updateUI();
    
    // Update active state on size buttons
    document.querySelectorAll('[data-size]').forEach(btn => {
      if (btn.getAttribute('data-size') === size) {
        btn.classList.add('bg-primary', 'text-white');
        btn.classList.remove('bg-gray-200', 'text-gray-900');
      } else {
        btn.classList.remove('bg-primary', 'text-white');
        btn.classList.add('bg-gray-200', 'text-gray-900');
      }
    });
  }

  function selectView(view) {
    currentView = view;
    updateImage();
    
    // Update active state on view buttons
    document.querySelectorAll('[data-view]').forEach(btn => {
      if (btn.getAttribute('data-view') === view) {
        btn.classList.add('border-primary');
        btn.classList.remove('border-transparent');
      } else {
        btn.classList.remove('border-primary');
        btn.classList.add('border-transparent');
      }
    });
  }

  function updateUI() {
    // Find the matching variant based on color and size
    currentVariant = processedVariants.find(variant => 
      variant.options.color === currentColor && 
      variant.options.size === currentSize
    );

    if (!currentVariant) {
      // If no exact match, try to find a variant with matching color
      currentVariant = processedVariants.find(variant => 
        variant.options.color === currentColor
      );
    }

    if (!currentVariant) {
      // Fallback to first variant
      currentVariant = processedVariants[0];
    }

    if (currentVariant) {
      // Update price
      const priceElement = document.getElementById('product-price');
      if (priceElement && currentVariant.retail_price) {
        priceElement.textContent = `$${currentVariant.retail_price.toFixed(2)}`;
      }

      // Update variant ID for add-to-cart form
      const variantInput = document.getElementById('variant-id');
      if (variantInput) {
        variantInput.value = currentVariant.id;
      }

      // Update available views
      updateAvailableViews();

      // Select first view if current view is not available
      if (currentVariant.mockupViews && currentVariant.mockupViews.length > 0) {
        const viewExists = currentVariant.mockupViews.some(v => v.view === currentView);
        if (!viewExists) {
          currentView = currentVariant.mockupViews[0].view;
        }
        updateImage();
      }
    }
  }

  function updateAvailableViews() {
    const viewsContainer = document.getElementById('product-views');
    if (!viewsContainer || !currentVariant || !currentVariant.mockupViews) return;

    // Hide all view buttons first
    document.querySelectorAll('[data-view]').forEach(btn => {
      btn.style.display = 'none';
    });

    // Show only available views for current variant
    currentVariant.mockupViews.forEach(mockupView => {
      const viewButton = document.querySelector(`[data-view="${mockupView.view}"]`);
      if (viewButton) {
        viewButton.style.display = 'block';
        
        // Update thumbnail if available
        const img = viewButton.querySelector('img');
        if (img) {
          img.src = mockupView.url;
          img.srcset = mockupView.webpUrl;
        }
      }
    });
  }

  function updateImage() {
    if (!currentVariant || !currentVariant.mockupViews) return;
    
    const mockupView = currentVariant.mockupViews.find(v => v.view === currentView);
    if (!mockupView) return;
    
    const mainImage = document.getElementById('main-image');
    if (!mainImage) return;
    
    const imgElement = mainImage.querySelector('img');
    const sourceElement = mainImage.querySelector('source');
    
    if (imgElement) {
      imgElement.src = mockupView.url;
      imgElement.alt = `${currentVariant.name} - ${mockupView.label}`;
    }
    
    if (sourceElement) {
      sourceElement.srcset = mockupView.webpUrl;
    }
  }
</script>
---